<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Liquid Shape Maker</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@300;400;500&family=DM+Mono:wght@300;400&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #0b0b12;
  --panel-bg: rgba(255,255,255,0.035);
  --panel-border: rgba(255,255,255,0.07);
  --text: rgba(255,255,255,0.82);
  --text-dim: rgba(255,255,255,0.38);
  --accent: #a78bfa;
  --panel-w: 292px;
}

html, body { width:100%; height:100%; overflow:hidden; background:var(--bg); font-family:'DM Sans',sans-serif; color:var(--text); user-select:none; }

#app { display:flex; width:100vw; height:100vh; }

#canvas-wrap {
  flex:1; position:relative;
  background: radial-gradient(ellipse 70% 70% at 50% 50%, #130e1f 0%, #07070d 70%);
}
#canvas-wrap canvas { display:block; width:100%!important; height:100%!important; }

/* ── Sidebar ── */
#sidebar {
  width:var(--panel-w); height:100vh;
  display:flex; flex-direction:column;
  padding:18px 14px 16px;
  background:rgba(9,9,18,0.82);
  backdrop-filter:blur(24px) saturate(1.5);
  -webkit-backdrop-filter:blur(24px) saturate(1.5);
  border-left:1px solid var(--panel-border);
  overflow-y:auto; overflow-x:hidden;
  scrollbar-width:thin; scrollbar-color:rgba(255,255,255,0.08) transparent;
  gap:0;
}
#sidebar::-webkit-scrollbar { width:3px; }
#sidebar::-webkit-scrollbar-thumb { background:rgba(255,255,255,0.08); border-radius:2px; }

.logo {
  font-family:'DM Mono',monospace; font-size:10px; letter-spacing:0.22em;
  text-transform:uppercase; color:var(--text-dim);
  margin-bottom:18px; padding-bottom:14px; border-bottom:1px solid var(--panel-border);
  display:flex; align-items:center; gap:8px;
}
.logo-dot {
  width:7px; height:7px; border-radius:50%; flex-shrink:0;
  background:conic-gradient(from 0deg,#38bdf8,#a78bfa,#f472b6,#34d399,#38bdf8);
  animation:spin 4s linear infinite;
}
@keyframes spin { to{transform:rotate(360deg);} }

/* ── Section ── */
.sec { margin-bottom:18px; }
.sec-label {
  font-size:9px; letter-spacing:0.18em; text-transform:uppercase;
  color:var(--text-dim); font-family:'DM Mono',monospace;
  margin-bottom:8px;
  display:flex; align-items:center; gap:6px;
}
.sec-label::before {
  content:''; display:block; width:5px; height:5px;
  border-radius:50%; background:var(--accent); opacity:0.6; flex-shrink:0;
}

.divider { height:1px; background:var(--panel-border); margin:14px 0; }

/* ── Shapes ── */
.shape-grid { display:grid; grid-template-columns:repeat(5,1fr); gap:5px; }
.shape-btn {
  aspect-ratio:1; background:var(--panel-bg); border:1px solid var(--panel-border);
  border-radius:9px; cursor:pointer; display:flex; flex-direction:column;
  align-items:center; justify-content:center; gap:3px; transition:all 0.16s; padding:4px 2px 3px;
}
.shape-btn svg { width:18px; height:18px; opacity:0.55; transition:opacity 0.16s; }
.shape-btn span { font-size:7px; letter-spacing:0.04em; text-transform:uppercase; color:var(--text-dim); font-family:'DM Mono',monospace; transition:color 0.16s; }
.shape-btn:hover { background:rgba(255,255,255,0.06); border-color:rgba(255,255,255,0.13); }
.shape-btn.active { background:rgba(167,139,250,0.14); border-color:rgba(167,139,250,0.45); }
.shape-btn.active svg { opacity:1; }
.shape-btn.active span { color:var(--accent); }

/* ── Style toggle ── */
.style-row { display:grid; grid-template-columns:1fr 1fr; gap:5px; }
.style-btn {
  padding:7px 6px; border-radius:8px; border:1px solid var(--panel-border);
  background:var(--panel-bg); color:var(--text-dim); font-family:'DM Sans',sans-serif;
  font-size:10px; cursor:pointer; text-align:center; transition:all 0.16s;
}
.style-btn:hover { background:rgba(255,255,255,0.06); }
.style-btn.active { background:rgba(167,139,250,0.14); border-color:rgba(167,139,250,0.45); color:var(--accent); }

/* ── Theme swatches ── */
.theme-grid { display:grid; grid-template-columns:repeat(3,1fr); gap:5px; }
.theme-btn {
  padding:7px 5px; border-radius:9px; border:1px solid var(--panel-border);
  background:var(--panel-bg); cursor:pointer; display:flex; flex-direction:column;
  align-items:center; gap:5px; transition:all 0.16s;
}
.theme-swatch { width:24px; height:24px; border-radius:50%; }
.theme-btn span { font-size:8px; color:var(--text-dim); white-space:nowrap; font-family:'DM Mono',monospace; transition:color 0.16s; }
.theme-btn:hover { background:rgba(255,255,255,0.06); }
.theme-btn.active { border-color:rgba(167,139,250,0.5); background:rgba(167,139,250,0.1); }
.theme-btn.active span { color:var(--accent); }

/* ── Color pickers ── */
.color-grid { display:grid; grid-template-columns:repeat(4,1fr); gap:5px; }
.color-item { display:flex; flex-direction:column; align-items:center; gap:3px; position:relative; }
.color-item label { font-size:8px; color:var(--text-dim); font-family:'DM Mono',monospace; }
input[type=color] {
  -webkit-appearance:none; width:100%; height:28px;
  border:1px solid var(--panel-border); border-radius:6px;
  background:none; cursor:pointer; padding:2px;
}
input[type=color]::-webkit-color-swatch-wrapper { padding:0; }
input[type=color]::-webkit-color-swatch { border-radius:4px; border:none; }

/* Remove button on color item */
.color-remove {
  position:absolute; top:-5px; right:-5px;
  width:14px; height:14px; border-radius:50%;
  background:rgba(239,68,68,0.7); border:none; cursor:pointer;
  color:#fff; font-size:9px; line-height:14px; text-align:center;
  display:none; padding:0; transition:background 0.15s;
  z-index:2;
}
.color-item:hover .color-remove { display:block; }
.color-remove:hover { background:rgba(239,68,68,1); }

/* Add color button */
.add-color-btn {
  aspect-ratio:1; height:28px; width:100%;
  border:1px dashed rgba(255,255,255,0.2); border-radius:6px;
  background:transparent; color:rgba(255,255,255,0.3);
  font-size:16px; cursor:pointer; transition:all 0.15s;
  display:flex; align-items:center; justify-content:center;
}
.add-color-btn:hover { border-color:var(--accent); color:var(--accent); background:rgba(167,139,250,0.08); }

/* ── Sliders ── */
.slider-wrap { margin-bottom:11px; }
.slider-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:5px; }
.slider-label { font-size:10px; color:var(--text-dim); }
.slider-val { font-size:9px; font-family:'DM Mono',monospace; color:var(--accent); min-width:26px; text-align:right; }
input[type=range] {
  -webkit-appearance:none; appearance:none; width:100%; height:2px;
  background:rgba(255,255,255,0.08); border-radius:2px; outline:none; cursor:pointer;
}
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance:none; width:12px; height:12px; border-radius:50%;
  background:var(--accent); cursor:pointer; box-shadow:0 0 6px rgba(167,139,250,0.55); transition:transform 0.14s;
}
input[type=range]::-webkit-slider-thumb:hover { transform:scale(1.25); }
input[type=range]::-moz-range-thumb {
  width:12px; height:12px; border-radius:50%; background:var(--accent);
  cursor:pointer; border:none; box-shadow:0 0 6px rgba(167,139,250,0.55);
}

/* ── Select ── */
.styled-select {
  width:100%; padding:7px 9px; border-radius:8px; border:1px solid var(--panel-border);
  background:var(--panel-bg); color:var(--text); font-family:'DM Sans',sans-serif;
  font-size:11px; cursor:pointer; outline:none; appearance:none;
  background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6' viewBox='0 0 10 6'%3E%3Cpath d='M1 1l4 4 4-4' stroke='rgba(255,255,255,0.3)' fill='none' stroke-width='1.5' stroke-linecap='round'/%3E%3C/svg%3E");
  background-repeat:no-repeat; background-position:right 9px center;
  padding-right:28px;
}
.styled-select:focus { border-color:rgba(167,139,250,0.4); }
.styled-select option { background:#1a1a2e; color:#fff; }

/* ── Toggle ── */
.toggle-row { display:flex; align-items:center; justify-content:space-between; margin-bottom:9px; }
.toggle-label { font-size:10px; color:var(--text-dim); }
.toggle { position:relative; width:32px; height:17px; cursor:pointer; }
.toggle input { opacity:0; width:0; height:0; }
.toggle-track { position:absolute; inset:0; background:rgba(255,255,255,0.08); border-radius:9px; transition:background 0.2s; }
.toggle input:checked + .toggle-track { background:rgba(167,139,250,0.55); }
.toggle-thumb { position:absolute; left:2px; top:2px; width:13px; height:13px; background:white; border-radius:50%; transition:transform 0.18s; box-shadow:0 1px 3px rgba(0,0,0,0.4); }
.toggle input:checked ~ .toggle-thumb { transform:translateX(15px); }

/* ── Playback ── */
.playback-row { display:flex; gap:6px; align-items:center; margin-bottom:12px; }
.icon-btn {
  width:32px; height:32px; border-radius:8px; border:1px solid var(--panel-border);
  background:var(--panel-bg); color:var(--text); cursor:pointer;
  display:flex; align-items:center; justify-content:center; transition:all 0.16s; flex-shrink:0;
}
.icon-btn:hover { background:rgba(255,255,255,0.07); border-color:rgba(255,255,255,0.15); }
.icon-btn svg { width:13px; height:13px; }
#rec-dot {
  width:6px; height:6px; border-radius:50%; background:#ef4444;
  display:none; margin-left:4px; animation:blink 0.9s ease-in-out infinite;
}
@keyframes blink { 0%,100%{opacity:1;} 50%{opacity:0.3;} }

/* ── Buttons ── */
.btn-row { display:flex; gap:5px; margin-bottom:5px; }
.btn {
  flex:1; padding:8px 6px; border-radius:9px; border:1px solid var(--panel-border);
  background:var(--panel-bg); color:var(--text); font-family:'DM Sans',sans-serif;
  font-size:10px; cursor:pointer; text-align:center; transition:all 0.16s; white-space:nowrap;
}
.btn:hover { background:rgba(255,255,255,0.07); border-color:rgba(255,255,255,0.15); }
.btn.primary { background:rgba(167,139,250,0.18); border-color:rgba(167,139,250,0.38); color:var(--accent); }
.btn.primary:hover { background:rgba(167,139,250,0.28); }
.btn.danger { background:rgba(239,68,68,0.15); border-color:rgba(239,68,68,0.4); color:#f87171; animation:blink 1s ease-in-out infinite; }

/* ── Sharp Fold controls block ── */
#sharp-controls {
  background: rgba(244,114,182,0.05);
  border: 1px solid rgba(244,114,182,0.18);
  border-radius: 10px;
  padding: 10px 10px 4px;
  margin-bottom: 11px;
}

/* ── Fluid Glass controls block ── */
#fluid-controls {
  background: rgba(167,139,250,0.06);
  border: 1px solid rgba(167,139,250,0.18);
  border-radius: 10px;
  padding: 10px 10px 4px;
  margin-bottom: 11px;
}

/* ── Effect group container ── */
.fx-group {
  border: 1px solid var(--panel-border);
  border-radius: 10px;
  margin-bottom: 8px;
  overflow: hidden;
}
.fx-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 7px 10px 6px;
  cursor: pointer;
  background: rgba(255,255,255,0.02);
  transition: background 0.15s;
  user-select: none;
}
.fx-header:hover { background: rgba(255,255,255,0.05); }
.fx-title {
  font-size: 9px;
  font-family: 'DM Mono', monospace;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: var(--text-dim);
  display: flex;
  align-items: center;
  gap: 6px;
}
.fx-title-dot {
  width: 5px; height: 5px;
  border-radius: 50%;
  background: var(--panel-border);
  flex-shrink: 0;
  transition: background 0.2s;
}
.fx-group.active .fx-title-dot { background: var(--accent); }
.fx-val-badge {
  font-size: 8px;
  font-family: 'DM Mono', monospace;
  color: var(--accent);
  opacity: 0;
  transition: opacity 0.2s;
}
.fx-group.active .fx-val-badge { opacity: 1; }
.fx-chevron {
  font-size: 8px;
  color: var(--text-dim);
  transition: transform 0.2s;
  line-height: 1;
}
.fx-group.open .fx-chevron { transform: rotate(180deg); }
.fx-body {
  display: none;
  padding: 8px 10px 6px;
  border-top: 1px solid var(--panel-border);
}
.fx-group.open .fx-body { display: block; }

/* ── Material preset buttons ── */
.mat-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 5px;
  margin-bottom: 11px;
}
.mat-btn {
  padding: 7px 4px 6px;
  border-radius: 9px;
  border: 1px solid var(--panel-border);
  background: var(--panel-bg);
  cursor: pointer;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  transition: all 0.16s;
}
.mat-btn:hover { background: rgba(255,255,255,0.06); }
.mat-btn.active { background: rgba(167,139,250,0.14); border-color: rgba(167,139,250,0.45); }
.mat-btn .mat-icon { font-size: 14px; line-height: 1; }
.mat-btn span { font-size: 7.5px; color: var(--text-dim); font-family:'DM Mono',monospace; transition: color 0.16s; }
.mat-btn.active span { color: var(--accent); }

/* ── Status ── */
.status {
  margin-top:auto; padding-top:12px; border-top:1px solid var(--panel-border);
  font-family:'DM Mono',monospace; font-size:9px; color:var(--text-dim); line-height:1.7;
}
.status-row { display:flex; justify-content:space-between; }

/* ── Toast ── */
#toast {
  position:fixed; bottom:20px; left:50%; pointer-events:none;
  transform:translateX(-50%) translateY(60px);
  background:rgba(20,20,36,0.96); border:1px solid rgba(167,139,250,0.3);
  color:var(--text); font-size:11px; padding:8px 18px; border-radius:30px;
  backdrop-filter:blur(12px); transition:transform 0.3s cubic-bezier(0.34,1.56,0.64,1);
  z-index:100; white-space:nowrap;
}
#toast.show { transform:translateX(-50%) translateY(0); }
</style>
</head>
<body>
<div id="app">
  <div id="canvas-wrap"><canvas id="c"></canvas></div>

  <div id="sidebar">
    <div class="logo"><div class="logo-dot"></div>Liquid Shape</div>

    <!-- SHAPE -->
    <div class="sec">
      <div class="sec-label">Shape</div>
      <div class="shape-grid">
        <button class="shape-btn active" data-shape="sphere" title="Sphere">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="12" cy="12" r="9"/><ellipse cx="12" cy="12" rx="4" ry="9"/><line x1="3" y1="12" x2="21" y2="12"/></svg>
          <span>Orb</span>
        </button>
        <button class="shape-btn" data-shape="rcube" title="Rounded Cube">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="4" y="4" width="16" height="16" rx="4"/></svg>
          <span>Cube</span>
        </button>
        <button class="shape-btn" data-shape="rtablet" title="Rounded Tablet">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="3" y="7" width="18" height="10" rx="5"/></svg>
          <span>Pill</span>
        </button>
        <button class="shape-btn" data-shape="torus" title="Torus">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><ellipse cx="12" cy="12" rx="9" ry="4"/><ellipse cx="12" cy="12" rx="3.5" ry="1.5"/></svg>
          <span>Ring</span>
        </button>
        <button class="shape-btn" data-shape="egg" title="Egg">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><ellipse cx="12" cy="13" rx="7" ry="9"/></svg>
          <span>Egg</span>
        </button>
        <button class="shape-btn" data-shape="capsule" title="Capsule">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="8" y="3" width="8" height="18" rx="4"/></svg>
          <span>Capsule</span>
        </button>
        <button class="shape-btn" data-shape="cone" title="Cone">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M12 3L20 19H4z"/><ellipse cx="12" cy="19" rx="8" ry="2"/></svg>
          <span>Cone</span>
        </button>
        <button class="shape-btn" data-shape="hemisphere" title="Hemisphere">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M3 12a9 9 0 0 1 18 0"/><line x1="3" y1="12" x2="21" y2="12"/></svg>
          <span>Dome</span>
        </button>
        <button class="shape-btn" data-shape="trefoil" title="Trefoil Knot">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M12 5c2 0 5 3 3 6s-5 2-5 5 3 5 5 3-1-5 2-6 5 1 3 4"/></svg>
          <span>Knot</span>
        </button>
        <button class="shape-btn" data-shape="twist" title="Twisted Torus">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M4 12c0-3 2-5 4-4s3 5 6 5 5-3 6-5"/><path d="M20 12c0 3-2 5-4 4s-3-5-6-5-5 3-6 5"/></svg>
          <span>Twist</span>
        </button>
        <button class="shape-btn" data-shape="star" title="Star">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><polygon points="12,2 15,9 22,9 17,14 19,21 12,17 5,21 7,14 2,9 9,9"/></svg>
          <span>Star</span>
        </button>
        <button class="shape-btn" data-shape="chain" title="Torus Knot 2">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M5 12c0-3 2-5 4-4s3 4 6 4 5-2 4-4"/><path d="M19 12c0 3-2 5-4 4s-3-4-6-4-5 2-4 4"/></svg>
          <span>Link</span>
        </button>
      </div>
    </div>

    <!-- SURFACE STYLE -->
    <div class="sec">
      <div class="sec-label">Surface</div>
      <div class="style-row">
        <button class="style-btn active" data-style="smooth">Liquid / Smooth</button>
      </div>
    </div>

    <div class="divider"></div>

    <!-- THEMES -->
    <div class="sec">
      <div class="sec-label">Theme</div>
      <div class="theme-grid" id="theme-grid"></div>
    </div>

    <!-- BASE COLOR -->
    <div class="sec">
      <div class="sec-label">Base Layer</div>
      <div style="display:flex; gap:8px; align-items:center; margin-bottom:10px;">
        <div class="color-item" style="flex-shrink:0">
          <label>Base</label>
          <input type="color" id="baseColor" value="#ffffff" style="width:44px;">
        </div>
        <div style="flex:1;">
          <div class="slider-header"><span class="slider-label">Color Opacity</span><span class="slider-val" id="colorOpacity-val">0.8</span></div>
          <input type="range" id="colorOpacity" min="0" max="1" step="0.01" value="0.82">
        </div>
      </div>
    </div>

    <!-- COLORS -->
    <div class="sec">
      <div class="sec-label">Color Palette</div>
      <div class="color-grid" id="color-grid">
        <!-- filled dynamically by JS -->
      </div>
    </div>

    <div class="divider"></div>

    <!-- COLOR PARAMS -->
    <div class="sec">
      <div class="sec-label">Color Params</div>
      <div class="slider-wrap">
        <div class="slider-header"><span class="slider-label">Gradient Type</span></div>
        <select class="styled-select" id="gradientType">
          <option value="linear">Linear (top → bottom)</option>
          <option value="radial">Radial (center → out)</option>
          <option value="fluid">✦ Fluid Glass</option>
          <option value="sharp">⚡ Sharp Fold</option>
        </select>
      </div>
      <!-- Sharp Fold controls -->
      <div id="sharp-controls" style="display:none;">
        <div class="slider-wrap">
          <div class="slider-header"><span class="slider-label" style="color:#f472b6;">⚡ Sharpness</span><span class="slider-val" id="sharpness-val">8.0</span></div>
          <input type="range" id="sharpness" min="1" max="30" step="0.5" value="8">
        </div>
        <div class="slider-wrap">
          <div class="slider-header"><span class="slider-label" style="color:#f472b6;">≈ Smooth Mix</span><span class="slider-val" id="smoothMix-val">0.5</span></div>
          <input type="range" id="smoothMix" min="0" max="1" step="0.01" value="0.5">
        </div>
        <div class="slider-wrap">
          <div class="slider-header"><span class="slider-label" style="color:#f472b6;">⌇ Band Scale</span><span class="slider-val" id="bandScale-val">1.5</span></div>
          <input type="range" id="bandScale" min="0.3" max="5" step="0.1" value="1.5">
        </div>
        <div class="slider-wrap">
          <div class="slider-header"><span class="slider-label" style="color:#f472b6;">⟳ Drift Speed</span><span class="slider-val" id="sharpDrift-val">0.3</span></div>
          <input type="range" id="sharpDrift" min="0" max="2" step="0.05" value="0.3">
        </div>
      </div>
      <!-- Fluid Glass controls — shown only when fluid mode active -->
      <div id="fluid-controls" style="display:none;">
        <div class="slider-wrap">
          <div class="slider-header"><span class="slider-label" style="color:#a78bfa;">⬡ Swirl Speed</span><span class="slider-val" id="fluidSwirl-val">1.0</span></div>
          <input type="range" id="fluidSwirl" min="0.1" max="4" step="0.05" value="1.0">
        </div>
        <div class="slider-wrap">
          <div class="slider-header"><span class="slider-label" style="color:#a78bfa;">◈ Thin-Film Iris</span><span class="slider-val" id="thinFilm-val">0.4</span></div>
          <input type="range" id="thinFilm" min="0" max="1" step="0.01" value="0.4">
        </div>
        <div class="slider-wrap">
          <div class="slider-header"><span class="slider-label" style="color:#a78bfa;">⟁ Chromatic Split</span><span class="slider-val" id="chromaticAb-val">0.3</span></div>
          <input type="range" id="chromaticAb" min="0" max="1" step="0.01" value="0.3">
        </div>
        <div class="slider-wrap">
          <div class="slider-header"><span class="slider-label" style="color:#a78bfa;">≋ Fold Lines</span><span class="slider-val" id="foldLines-val">0.5</span></div>
          <input type="range" id="foldLines" min="0" max="1" step="0.01" value="0.5">
        </div>
      </div>
      <div class="slider-wrap">
        <div class="slider-header"><span class="slider-label">Color Warp</span><span class="slider-val" id="colorWarp-val">0.4</span></div>
        <input type="range" id="colorWarp" min="0" max="1" step="0.01" value="0.4">
      </div>
      <div class="slider-wrap">
        <div class="slider-header"><span class="slider-label">Fresnel Edge</span><span class="slider-val" id="fresnel-val">0.5</span></div>
        <input type="range" id="fresnelIntensity" min="0" max="2" step="0.05" value="0.5">
      </div>
      <div class="slider-wrap">
        <div class="slider-header"><span class="slider-label">Light Brightness</span><span class="slider-val" id="lightBrightness-val">1.0</span></div>
        <input type="range" id="lightBrightness" min="0" max="2" step="0.1" value="1.0">
      </div>
      <div class="slider-wrap">
        <div class="slider-header"><span class="slider-label">Light Scale</span><span class="slider-val" id="lightScale-val">5.0</span></div>
        <input type="range" id="lightScale" min="1" max="20" step="0.5" value="5.0">
      </div>
    </div>

    <div class="divider"></div>

    <!-- SHAPE & MOTION -->
    <div class="sec">
      <div class="sec-label">Shape & Motion</div>
      <div class="slider-wrap">
        <div class="slider-header"><span class="slider-label">Flow Speed</span><span class="slider-val" id="speed-val">0.6</span></div>
        <input type="range" id="speed" min="0" max="2" step="0.05" value="0.6">
      </div>
      <div class="slider-wrap">
        <div class="slider-header"><span class="slider-label">Distortion</span><span class="slider-val" id="distortion-val">0.30</span></div>
        <input type="range" id="distortion" min="0" max="0.8" step="0.01" value="0.30">
      </div>
      <div class="slider-wrap">
        <div class="slider-header"><span class="slider-label">Turbulence</span><span class="slider-val" id="turbulence-val">0.0</span></div>
        <input type="range" id="turbulence" min="0" max="1" step="0.01" value="0.0">
      </div>
      <div class="toggle-row">
        <span class="toggle-label">Auto rotate</span>
        <label class="toggle"><input type="checkbox" id="rotate-toggle" checked><div class="toggle-track"></div><div class="toggle-thumb"></div></label>
      </div>
    </div>

    <div class="divider"></div>

    <!-- MATERIAL PRESET -->
    <div class="sec">
      <div class="sec-label">Material</div>
      <div class="mat-grid" id="mat-grid">
        <button class="mat-btn active" data-mat="glossy">
          <span class="mat-icon">◉</span><span>Glossy</span>
        </button>
        <button class="mat-btn" data-mat="matte">
          <span class="mat-icon">○</span><span>Matte</span>
        </button>
        <button class="mat-btn" data-mat="metallic">
          <span class="mat-icon">◈</span><span>Metal</span>
        </button>
        <button class="mat-btn" data-mat="plastic">
          <span class="mat-icon">◎</span><span>Plastic</span>
        </button>
        <button class="mat-btn" data-mat="fuzzy">
          <span class="mat-icon">❋</span><span>Fuzzy</span>
        </button>
        <button class="mat-btn" data-mat="ceramic">
          <span class="mat-icon">◌</span><span>Ceramic</span>
        </button>
      </div>
      <!-- Fine-tune sliders -->
      <div class="slider-wrap">
        <div class="slider-header"><span class="slider-label">Roughness</span><span class="slider-val" id="roughness-val">0.0</span></div>
        <input type="range" id="roughness" min="0" max="1" step="0.01" value="0">
      </div>
      <div class="slider-wrap">
        <div class="slider-header"><span class="slider-label">Metallic</span><span class="slider-val" id="metallic-val">0.0</span></div>
        <input type="range" id="metallic" min="0" max="1" step="0.01" value="0">
      </div>
      <div class="slider-wrap">
        <div class="slider-header"><span class="slider-label">Specular</span><span class="slider-val" id="specPow-val">64</span></div>
        <input type="range" id="specPow" min="2" max="256" step="1" value="64">
      </div>
      <div class="slider-wrap">
        <div class="slider-header"><span class="slider-label">Fuzz / Velvet</span><span class="slider-val" id="fuzzy-val">0.0</span></div>
        <input type="range" id="fuzzyIntensity" min="0" max="1" step="0.01" value="0">
      </div>
      <div class="toggle-row" style="margin-top:4px;">
        <span class="toggle-label">✦ Metallic Layer</span>
        <label class="toggle"><input type="checkbox" id="metallic-toggle"><div class="toggle-track"></div><div class="toggle-thumb"></div></label>
      </div>
      <div id="metallic-controls" style="display:none; margin-top:8px;">
        <div class="slider-wrap">
          <div class="slider-header"><span class="slider-label" style="color:#fbbf24;">Envmap Strength</span><span class="slider-val" id="envStrength-val">0.6</span></div>
          <input type="range" id="envStrength" min="0" max="1" step="0.01" value="0.6">
        </div>
        <div class="slider-wrap">
          <div class="slider-header"><span class="slider-label" style="color:#fbbf24;">Anisotropy</span><span class="slider-val" id="aniso-val">0.5</span></div>
          <input type="range" id="aniso" min="0" max="1" step="0.01" value="0.5">
        </div>
      </div>
    </div>

    <div class="divider"></div>

    <!-- TEXTURE EFFECTS -->
    <div class="sec">
      <div class="sec-label">Effects</div>

      <!-- Filament -->
      <div class="fx-group" id="fx-filament">
        <div class="fx-header">
          <span class="fx-title"><span class="fx-title-dot"></span>Filament</span>
          <span class="fx-val-badge" id="fx-filament-badge">0.0</span>
          <span class="fx-chevron">▾</span>
        </div>
        <div class="fx-body">
          <div class="slider-wrap">
            <div class="slider-header"><span class="slider-label">Intensity</span><span class="slider-val" id="filament-val">0.0</span></div>
            <input type="range" id="filamentIntensity" min="0" max="1" step="0.01" value="0">
          </div>
          <div class="slider-wrap" style="margin-bottom:2px;">
            <div class="slider-header"><span class="slider-label">Scale</span><span class="slider-val" id="filamentScale-val">4.0</span></div>
            <input type="range" id="filamentScale" min="1" max="10" step="0.1" value="4">
          </div>
        </div>
      </div>

      <!-- Topo -->
      <div class="fx-group" id="fx-topo">
        <div class="fx-header">
          <span class="fx-title"><span class="fx-title-dot"></span>Contour</span>
          <span class="fx-val-badge" id="fx-topo-badge">0.0</span>
          <span class="fx-chevron">▾</span>
        </div>
        <div class="fx-body">
          <div class="slider-wrap">
            <div class="slider-header"><span class="slider-label">Intensity</span><span class="slider-val" id="topo-val">0.0</span></div>
            <input type="range" id="topoIntensity" min="0" max="1" step="0.01" value="0">
          </div>
          <div class="slider-wrap" style="margin-bottom:2px;">
            <div class="slider-header"><span class="slider-label">Frequency</span><span class="slider-val" id="topoFreq-val">10.0</span></div>
            <input type="range" id="topoFreq" min="1" max="20" step="0.5" value="10">
          </div>
        </div>
      </div>

      <!-- Ripple -->
      <div class="fx-group" id="fx-ripple">
        <div class="fx-header">
          <span class="fx-title"><span class="fx-title-dot"></span>Ripple</span>
          <span class="fx-val-badge" id="fx-ripple-badge">0.0</span>
          <span class="fx-chevron">▾</span>
        </div>
        <div class="fx-body">
          <div class="slider-wrap">
            <div class="slider-header"><span class="slider-label">Intensity</span><span class="slider-val" id="ripple-val">0.0</span></div>
            <input type="range" id="rippleIntensity" min="0" max="1" step="0.01" value="0">
          </div>
          <div class="slider-wrap" style="margin-bottom:2px;">
            <div class="slider-header"><span class="slider-label">Frequency</span><span class="slider-val" id="rippleFreq-val">10.0</span></div>
            <input type="range" id="rippleFreq" min="1" max="30" step="0.5" value="10">
          </div>
        </div>
      </div>

      <!-- Noise -->
      <div class="fx-group" id="fx-noise">
        <div class="fx-header">
          <span class="fx-title"><span class="fx-title-dot"></span>Noise</span>
          <span class="fx-val-badge" id="fx-noise-badge">0.0</span>
          <span class="fx-chevron">▾</span>
        </div>
        <div class="fx-body">
          <div class="slider-wrap">
            <div class="slider-header"><span class="slider-label">Intensity</span><span class="slider-val" id="noise-val">0.0</span></div>
            <input type="range" id="noiseIntensity" min="0" max="1" step="0.01" value="0">
          </div>
          <div class="slider-wrap" style="margin-bottom:2px;">
            <div class="slider-header"><span class="slider-label">Scale</span><span class="slider-val" id="noiseScale-val">15.0</span></div>
            <input type="range" id="noiseScale" min="1" max="50" step="1" value="15">
          </div>
        </div>
      </div>

    </div>

    <div class="divider"></div>

    <!-- PLAYBACK -->
    <div class="sec">
      <div class="sec-label">Playback</div>
      <div class="playback-row">
        <button class="icon-btn" id="play-btn" title="Play/Pause">
          <svg id="play-icon" viewBox="0 0 24 24" fill="currentColor" style="display:none"><path d="M6 4l15 8-15 8z"/></svg>
          <svg id="pause-icon" viewBox="0 0 24 24" fill="currentColor"><rect x="6" y="4" width="4" height="16" rx="1"/><rect x="14" y="4" width="4" height="16" rx="1"/></svg>
        </button>
        <div id="rec-dot"></div>
      </div>
    </div>

    <!-- EXPORT -->
    <div class="sec">
      <div class="sec-label">Export</div>
      <div class="btn-row">
        <button class="btn" id="export-png">PNG</button>
        <button class="btn" id="export-jpg">JPEG</button>
      </div>
      <div class="btn-row">
        <button class="btn primary" id="export-video">● Record WebM</button>
      </div>
    </div>

    <div class="status">
      <div class="status-row"><span>fps</span><span id="fps-val">—</span></div>
      <div class="status-row"><span>time</span><span id="time-val">0.0s</span></div>
    </div>
  </div><!-- /sidebar -->
</div><!-- /app -->

<div id="toast"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script>
/* ═══════════════════════════════════════════════════════
   LIQUID SHAPE MAKER
   Base: liquid-shape-generator.html shader system
   UI: dark glassmorphism sidebar + preset themes
   ═══════════════════════════════════════════════════════ */

// ── GLSL helpers (from original file) ───────────────────
const noiseGLSL = `
  vec3 mod289v3(vec3 x){ return x - floor(x*(1.0/289.0))*289.0; }
  vec4 mod289v4(vec4 x){ return x - floor(x*(1.0/289.0))*289.0; }
  vec4 permute4(vec4 x){ return mod289v4(((x*34.0)+1.0)*x); }
  vec4 taylorInvSqrt4(vec4 r){ return 1.79284291400159 - 0.85373472095314*r; }

  float snoise(vec3 v){
    const vec2 C = vec2(1.0/6.0, 1.0/3.0);
    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
    vec3 i  = floor(v + dot(v, C.yyy));
    vec3 x0 = v - i + dot(i, C.xxx);
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min(g.xyz, l.zxy);
    vec3 i2 = max(g.xyz, l.zxy);
    vec3 x1 = x0 - i1 + C.xxx;
    vec3 x2 = x0 - i2 + C.yyy;
    vec3 x3 = x0 - D.yyy;
    i = mod289v3(i);
    vec4 p = permute4(permute4(permute4(
      i.z+vec4(0.0,i1.z,i2.z,1.0))+
      i.y+vec4(0.0,i1.y,i2.y,1.0))+
      i.x+vec4(0.0,i1.x,i2.x,1.0));
    float n_ = 0.142857142857;
    vec3  ns = n_*D.wyz - D.xzx;
    vec4 j = p - 49.0*floor(p*ns.z*ns.z);
    vec4 x_ = floor(j*ns.z);
    vec4 y_ = floor(j - 7.0*x_);
    vec4 x  = x_*ns.x + ns.yyyy;
    vec4 y  = y_*ns.x + ns.yyyy;
    vec4 h  = 1.0 - abs(x) - abs(y);
    vec4 b0 = vec4(x.xy, y.xy);
    vec4 b1 = vec4(x.zw, y.zw);
    vec4 s0 = floor(b0)*2.0+1.0;
    vec4 s1 = floor(b1)*2.0+1.0;
    vec4 sh = -step(h, vec4(0.0));
    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
    vec3 p0 = vec3(a0.xy, h.x);
    vec3 p1 = vec3(a0.zw, h.y);
    vec3 p2 = vec3(a1.xy, h.z);
    vec3 p3 = vec3(a1.zw, h.w);
    vec4 norm = taylorInvSqrt4(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));
    p0*=norm.x; p1*=norm.y; p2*=norm.z; p3*=norm.w;
    vec4 m = max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);
    m=m*m;
    return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));
  }

  vec2 hash22(vec2 p){
    p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));
    return fract(sin(p)*43758.5453);
  }

  float voronoi(vec3 p){
    vec2 n = floor(p.xy), f = fract(p.xy);
    float md = 1.0;
    for(int i=-1;i<=1;i++) for(int j=-1;j<=1;j++){
      vec2 nb = vec2(float(i),float(j));
      vec2 pt = hash22(n+nb);
      pt = 0.5 + 0.5*sin(p.z + 6.2831*pt);
      vec2 d = nb + pt - f;
      md = min(md, length(d));
    }
    return md;
  }
`;

// ── Vertex Shader ───────────────────────────────────────
const vertexShader = `
  uniform float uTime;
  uniform float uDistortion;
  uniform float uTurbulence;
  uniform float uFilamentIntensity;
  uniform float uFilamentScale;
  uniform float uVoronoiIntensity;
  uniform float uVoronoiScale;
  uniform float uTopoIntensity;
  uniform float uTopoFreq;
  uniform float uRippleIntensity;
  uniform float uRippleFreq;
  uniform float uStyle;

  varying vec3 vNormal;
  varying vec3 vPosition;
  varying vec3 vViewDir;

  ${noiseGLSL}

  float getDisplacement(vec3 pos){
    // uStyle < 0.5 → Liquid/Smooth: low freq, big gentle waves
    // uStyle > 0.5 → Organic/Crystal: high freq, sharp bumps
    float freq1 = (uStyle > 0.5) ? 1.5 : 0.8;
    float d1 = snoise(pos * freq1 + uTime * 0.3) * uDistortion;

    // Turbulence layer (always present)
    float d2 = snoise(pos * 4.0 + uTime * 1.5) * uTurbulence * 0.5;

    // Filament / web
    float ridge = abs(snoise(pos*uFilamentScale + uTime*0.2));
    float d3 = (1.0 - pow(ridge, 0.5)) * uFilamentIntensity * 0.5;

    // Voronoi / cell
    float d4 = (1.0 - voronoi(pos*uVoronoiScale + uTime*0.1)) * uVoronoiIntensity * 0.2;

    // Topographic bands
    float topoN = snoise(pos + uTime*0.1);
    float bands = smoothstep(0.8, 1.0, sin(topoN*uTopoFreq));
    float d5 = bands * uTopoIntensity * 0.3;

    // Ripple
    float rip = sin(length(pos.xz)*uRippleFreq + uTime*2.0)
              + sin(length(pos.xy)*uRippleFreq*0.8 - uTime*1.5);
    float d6 = rip * uRippleIntensity * 0.1;

    return d1 + d2 - d3 + d4 + d5 + d6;
  }

  void main(){
    vPosition = position;
    float disp = getDisplacement(position);
    vec3 newPos = position + normal * disp;

    // Liquid: recalculate normals from displacement gradient → smooth shading
    // Organic/Crystal: keep original face normals → sharp faceted look
    if(uStyle < 0.5){
      float eps = 0.1;
      float dx = getDisplacement(position+vec3(eps,0,0)) - getDisplacement(position-vec3(eps,0,0));
      float dy = getDisplacement(position+vec3(0,eps,0)) - getDisplacement(position-vec3(0,eps,0));
      float dz = getDisplacement(position+vec3(0,0,eps)) - getDisplacement(position-vec3(0,0,eps));
      vNormal = normalize(normal - vec3(dx,dy,dz)/(2.0*eps));
    } else {
      vNormal = normal;
    }

    vec4 mvPos = modelViewMatrix * vec4(newPos, 1.0);
    vViewDir = normalize(-mvPos.xyz);
    gl_Position = projectionMatrix * mvPos;
  }
`;

// ── Fragment Shader ─────────────────────────────────────
const fragmentShader = `
  uniform vec3  uBaseColor;
  uniform float uColorOpacity;
  uniform float uTime;
  uniform float uLightBrightness, uLightScale;
  uniform float uColorWarp, uGradientType;
  uniform float uFresnelIntensity;
  uniform float uNoiseIntensity, uNoiseScale;
  // Fluid Glass
  uniform float uFluidSwirl;
  uniform float uThinFilm;
  uniform float uChromaticAb;
  uniform float uFoldLines;
  // Sharp Fold
  uniform float uSharpness;
  uniform float uSmoothMix;
  uniform float uBandScale;
  uniform float uSharpDrift;
  // Material system
  uniform float uRoughness;
  uniform float uMetallic;
  uniform float uSpecPow;
  uniform float uFuzzyIntensity;
  uniform float uEnvStrength;
  uniform float uAniso;
  uniform float uMetallicLayer; // 0=off, 1=on

  varying vec3 vNormal;
  varying vec3 vPosition;
  varying vec3 vViewDir;

  ${noiseGLSL}

  // Supports up to 12 colors, uColorCount tells how many are active
  uniform int uColorCount;
  uniform vec3 uColors[12];

  vec3 getPalette(float t){
    t = clamp(t, 0.0, 1.0);
    int n = uColorCount;
    if(n <= 1) return uColors[0];
    float seg = 1.0 / float(n - 1);
    for(int i = 0; i < 11; i++){
      if(i >= n - 1) break;
      float lo = float(i) * seg;
      float hi = float(i + 1) * seg;
      if(t >= lo && t <= hi)
        return mix(uColors[i], uColors[i + 1], (t - lo) / seg);
    }
    return uColors[n - 1];
  }

  // ── Fluid Glass color coordinate ─────────────────────
  float fluidColorT(vec3 p, float time, float swirl){
    float n1 = snoise(p * 0.9  + time * 0.12 * swirl);
    float n2 = snoise(p * 1.8  - time * 0.07 * swirl + vec3(1.7, 0.4, 2.1));
    float n3 = snoise(p * 0.45 + time * 0.04 * swirl + vec3(3.3, 1.1, 0.8));
    return (n1*0.50 + n2*0.32 + n3*0.18) * 0.5 + 0.5;
  }

  // ── Thin-film iridescence ─────────────────────────────
  vec3 thinFilmTint(float NdotV, float time, float intensity){
    float phase = NdotV * 3.14159 * 3.0 + time * 0.25;
    float r = sin(phase)          * 0.5 + 0.5;
    float g = sin(phase + 2.094)  * 0.5 + 0.5;
    float b = sin(phase + 4.189)  * 0.5 + 0.5;
    return vec3(r, g, b) * intensity;
  }

  // ── Fake environment map (procedural cube-like reflection) ──
  // Simulates a gradient sky env — warm top, cool sides, dark bottom.
  vec3 fakeEnvMap(vec3 R, float time){
    // Slowly rotating env
    float a = time * 0.04;
    float ca = cos(a), sa = sin(a);
    vec3 Rr = vec3(R.x*ca - R.z*sa, R.y, R.x*sa + R.z*ca);
    // Gradient sky
    float up = Rr.y * 0.5 + 0.5;
    vec3 sky = mix(vec3(0.05, 0.04, 0.10), vec3(0.90, 0.92, 1.00), up);
    // Horizon highlight band
    float horiz = 1.0 - abs(Rr.y);
    horiz = pow(horiz, 4.0);
    sky = mix(sky, vec3(1.0, 0.97, 0.90), horiz * 0.5);
    // Anisotropic streak (brushed metal look)
    float streak = abs(sin(Rr.x * 8.0 + time * 0.1)) * 0.15;
    sky += streak;
    return clamp(sky, 0.0, 1.0);
  }

  void main(){
    vec3 N = normalize(vNormal);
    vec3 V = normalize(vViewDir);
    float NdotV = max(0.0, dot(N, V));

    // ── Color coordinate ─────────────────────────────────
    float colorT;
    float warpN = snoise(vPosition*2.0 + uTime*0.2);

    if(uGradientType < 0.5){
      // ── Linear ───────────────────────────────────────────
      float linear = vPosition.y*0.5 + 0.5;
      colorT = clamp(linear + warpN*uColorWarp, 0.0, 1.0);

    } else if(uGradientType < 1.5){
      // ── Radial ───────────────────────────────────────────
      float radial = clamp(length(vPosition)/1.5, 0.0, 1.0);
      colorT = clamp(radial + warpN*uColorWarp, 0.0, 1.0);

    } else if(uGradientType < 2.5){
      // ── Fluid Glass ──────────────────────────────────────
      float fluid = fluidColorT(vPosition, uTime, max(uFluidSwirl, 0.5));
      float warp2 = snoise(vPosition*3.5 + uTime*0.18) * uColorWarp * 0.5;
      colorT = clamp(fluid + warp2, 0.0, 1.0);

    } else {
      // ── Sharp Fold ───────────────────────────────────────
      // Base: slow drifting noise pools (like fluid), but quantized into bands
      float drift = uTime * uSharpDrift;
      float n1 = snoise(vPosition * uBandScale       + drift * vec3(0.7, 0.4, 0.5));
      float n2 = snoise(vPosition * uBandScale * 2.1 - drift * vec3(0.3, 0.8, 0.2) + vec3(2.1, 1.4, 0.8));
      float n3 = snoise(vPosition * uBandScale * 0.5 + drift * vec3(0.2, 0.3, 0.6) + vec3(5.2, 3.1, 1.7));

      // Smooth base (weighted blend → natural colour pools)
      float smoothT = (n1 * 0.55 + n2 * 0.28 + n3 * 0.17) * 0.5 + 0.5;

      // Sharp version: posterize smoothT into hard bands
      // smoothstep-based quantization — keeps anti-aliased edges at transitions
      float bands = float(uColorCount - 1);
      float q = floor(smoothT * bands) / bands;           // stepped
      float qNext = (floor(smoothT * bands) + 1.0) / bands;
      // fraction within the current band [0,1]
      float frac = fract(smoothT * bands);
      // Edge sharpness: smoothstep width controlled by uSharpness
      // high uSharpness → very narrow transition zone → knife-edge
      float edgeWidth = 1.0 / max(uSharpness, 0.5);
      float blend = smoothstep(0.5 - edgeWidth, 0.5 + edgeWidth, frac);
      float sharpT = mix(q, qNext, blend);

      // Mix sharp and smooth — uSmoothMix=0 → all sharp, 1 → all smooth
      colorT = mix(sharpT, smoothT, uSmoothMix);

      // Add colour warp on top
      colorT = clamp(colorT + warpN * uColorWarp * 0.3, 0.0, 1.0);
    }

    // ── Base palette color (with optional chromatic ab) ──
    vec3 base;
    if(uGradientType > 1.5 && uChromaticAb > 0.001){
      float spread = uChromaticAb * 0.08;
      base = vec3(
        getPalette(clamp(colorT - spread, 0.0, 1.0)).r,
        getPalette(colorT).g,
        getPalette(clamp(colorT + spread, 0.0, 1.0)).b
      );
    } else {
      base = getPalette(colorT);
    }

    // ── Thin-film iridescence ─────────────────────────────
    if(uThinFilm > 0.001){
      vec3 film = thinFilmTint(NdotV, uTime, uThinFilm);
      base = clamp(mix(base, base * 0.6 + film * 0.4, uThinFilm), 0.0, 1.0);
    }

    // ── Fold / contour lines (fixed — proper isoline) ────
    // Compute gradient magnitude of noise → lines at level-set crossings
    if(uFoldLines > 0.001){
      // Two noise fields for cross-hatch soap-film look
      vec3 ps = vPosition * 3.0 + uTime * 0.08;
      vec3 ps2 = vPosition * 1.7 - uTime * 0.05 + vec3(4.4, 1.9, 3.1);

      float eps = 0.04;
      // Finite-difference gradient of noise field 1
      float nx0 = snoise(ps - vec3(eps,0,0)), nx1 = snoise(ps + vec3(eps,0,0));
      float ny0 = snoise(ps - vec3(0,eps,0)), ny1 = snoise(ps + vec3(0,eps,0));
      float nz0 = snoise(ps - vec3(0,0,eps)), nz1 = snoise(ps + vec3(0,0,eps));
      float gradMag = length(vec3(nx1-nx0, ny1-ny0, nz1-nz0)) / (2.0*eps);
      float fv = snoise(ps);
      // Lines at integer crossings of fv — width inversely proportional to gradient
      float lineWidth = mix(0.018, 0.055, 1.0 - clamp(gradMag * 0.5, 0.0, 1.0));
      float line1 = 1.0 - smoothstep(0.0, lineWidth, abs(fract(fv * 2.0 + 0.5) - 0.5) * 2.0);

      // Noise field 2 — lower freq, wider lines
      float fv2 = snoise(ps2);
      float line2 = 1.0 - smoothstep(0.0, 0.04, abs(fract(fv2 * 1.3 + 0.5) - 0.5) * 2.0);

      float foldMask = clamp((line1 * 0.65 + line2 * 0.35) * uFoldLines * 1.4, 0.0, 1.0);
      vec3 foldCol = mix(vec3(0.78, 0.86, 1.0), vec3(1.0), 0.55); // silver-white/blue
      base = mix(base, foldCol, foldMask);
    }

    // ── Animated light blobs ──────────────────────────────
    float t = uTime*0.5;
    float l1 = smoothstep(0.3, 0.7, snoise(vPosition*uLightScale + vec3(t, 0.0, t*0.5)));
    float l2 = smoothstep(0.4, 0.8, snoise(vPosition*(uLightScale*1.5) - vec3(0.0, t, -t)));
    float lightMask = clamp((l1*0.6 + l2*0.4) * uLightBrightness, 0.0, 1.0);
    base = mix(base, vec3(1.0), lightMask * 0.55);

    // ── Visual noise ──────────────────────────────────────
    if(uNoiseIntensity > 0.001){
      float noiseV = snoise(vPosition*uNoiseScale + uTime*0.05)*0.5 + 1.0;
      base = mix(base, base*noiseV, uNoiseIntensity);
    }

    // ── MATERIAL SYSTEM ───────────────────────────────────
    vec3 L  = normalize(vec3(1.5, 2.0, 1.2));
    vec3 L2 = normalize(vec3(-1.2, -0.5, 1.0));  // fill light
    vec3 H  = normalize(L + V);
    float NdotL  = max(0.0, dot(N, L));
    float NdotL2 = max(0.0, dot(N, L2));

    // Roughness → blurs specular (fake: lower exponent)
    float roughSpec = mix(uSpecPow, 2.0, uRoughness);

    // Diffuse: Lambertian + fill light, reduced by roughness
    float diffuse = NdotL * 0.8 + NdotL2 * 0.15 + 0.18; // soft ambient
    // Matte: increase diffuse, kill specular
    diffuse = mix(diffuse, 1.0, uRoughness * 0.4);

    // Specular
    float specVal = pow(max(0.0, dot(N, H)), roughSpec);
    // Anisotropic highlight for metallic — elongated along U tangent
    vec3 T = normalize(cross(N, vec3(0.0, 1.0, 0.01))); // tangent
    float TdotH = dot(T, H);
    float anisoSpec = pow(max(0.0, 1.0 - abs(TdotH)), mix(2.0, 20.0, uAniso));
    specVal = mix(specVal, anisoSpec * specVal, uMetallic);

    // Fuzzy / velvet: backscattering at grazing angles
    float fuzzy = pow(1.0 - NdotV, 2.5) * uFuzzyIntensity;
    vec3 fuzzyColor = mix(base * 1.3, vec3(1.0), 0.3);
    base = mix(base, fuzzyColor, clamp(fuzzy, 0.0, 0.8));

    // Apply diffuse shading (only for non-fluid / non-emissive materials)
    // Soft: blend diffuse so pure iridescent colors aren't killed
    float shadingBlend = mix(0.25, 0.85, uRoughness + uMetallic * 0.5);
    base = mix(base, base * diffuse, shadingBlend);

    // Specular highlight
    float specStrength = mix(0.7, 0.3, uRoughness); // rougher = dimmer spec
    base = mix(base, vec3(1.0), clamp(specVal * specStrength, 0.0, 0.85));

    // ── Metallic env reflection layer ─────────────────────
    if(uMetallicLayer > 0.5){
      vec3 R = reflect(-V, N);
      vec3 envCol = fakeEnvMap(R, uTime);
      // Schlick-like reflection: stronger at grazing angles
      float schlick = uMetallic + (1.0 - uMetallic) * pow(1.0 - NdotV, 5.0);
      float envMix = clamp(schlick * uEnvStrength, 0.0, 0.75);
      // Tint env with base color for metallic look
      vec3 tintedEnv = mix(envCol, base * envCol * 1.5, uMetallic * 0.7);
      base = mix(base, tintedEnv, envMix);
    }

    // ── Fresnel rim ───────────────────────────────────────
    float fresnelPow = (uGradientType > 1.5) ? 2.2 : mix(3.0, 1.8, uMetallic);
    float fresnel = pow(1.0 - NdotV, fresnelPow);
    vec3 fresnelCol = (uGradientType > 1.5)
      ? mix(vec3(0.80, 0.88, 1.0), vec3(1.0), 0.4)
      : mix(vec3(1.0), base * 1.4, uMetallic * 0.5);
    base = mix(base, fresnelCol, clamp(fresnel * uFresnelIntensity, 0.0, 0.92));

    base = clamp(base, 0.0, 1.0);

    gl_FragColor = vec4(base, uColorOpacity);
  }
`;

// ── Theme presets — 15 themes ─────────────────────────────
const THEMES = [
  // ── İridescent referans (ilk verilen görseldeki renkler) — Fluid Glass için optimize
  { id:'iridescent', name:'Pearl',    swatch:'conic-gradient(#38bdf8,#a78bfa,#f472b6,#ffd6e8,#c4f0ff,#7ee8fa,#38bdf8)',
    colors:['#38bdf8','#a78bfa','#f472b6','#e879a0','#ffd6e8','#c4f0ff','#7ee8fa'] },

  // ── Mevcut temalar
  { id:'soap',    name:'Soap',    swatch:'conic-gradient(#a8edea,#c3cfe2,#fed6e3,#a8edea)',
    colors:['#a8edea','#c3cfe2','#fed6e3','#ffffff'] },
  { id:'aurora',  name:'Aurora',  swatch:'conic-gradient(#43e97b,#38f9d7,#5ee7df,#b490ca,#43e97b)',
    colors:['#43e97b','#38f9d7','#5ee7df','#b490ca'] },
  { id:'sunset',  name:'Sunset',  swatch:'conic-gradient(#fa709a,#fee140,#f5af19,#fa709a)',
    colors:['#fa709a','#fee140','#f5af19','#ffffff'] },
  { id:'ocean',   name:'Ocean',   swatch:'conic-gradient(#0f3460,#00d2ff,#c9ffbf,#0f3460)',
    colors:['#0f3460','#16213e','#00d2ff','#c9ffbf'] },
  { id:'galaxy',  name:'Galaxy',  swatch:'conic-gradient(#7928ca,#ff0080,#4f46e5,#7928ca)',
    colors:['#7928ca','#ff0080','#4f46e5','#e0c3fc'] },
  { id:'jade',    name:'Jade',    swatch:'conic-gradient(#6ee7b7,#fde68a,#a7f3d0,#6ee7b7)',
    colors:['#6ee7b7','#fde68a','#a7f3d0','#ffffff'] },

  // ── Yeni trendler
  { id:'rosegold',   name:'Rose Gold', swatch:'conic-gradient(#f4a4a4,#f9d5c0,#e8c4c4,#fce4ec,#f4a4a4)',
    colors:['#e8a0a0','#f4cdb5','#dba8b8','#fce4ec'] },
  { id:'cyberpunk',  name:'Cyber',     swatch:'conic-gradient(#ff007a,#00ffb3,#0088ff,#ff007a)',
    colors:['#1b1b2a','#ff007a','#00ffb3','#0088ff'] },
  { id:'lava',       name:'Lava',      swatch:'conic-gradient(#8b0000,#ff4500,#ff8c00,#8b0000)',
    colors:['#1a0500','#8b0000','#ff4500','#ffcc00'] },
  { id:'nordic',     name:'Nordic',    swatch:'conic-gradient(#9fcccb,#c8dce0,#e4eff0,#9fcccb)',
    colors:['#6ba3a2','#9fcccb','#c8dce0','#e8f4f5'] },
  { id:'cotton',     name:'Candy',     swatch:'conic-gradient(#ffb3d9,#ffc0e0,#d4a5e8,#b5d5f5,#ffb3d9)',
    colors:['#ffc0e0','#ffb3d9','#d4a5e8','#b5d5f5'] },
  { id:'forest',     name:'Forest',    swatch:'conic-gradient(#2d5016,#468b47,#a8d5a8,#2d5016)',
    colors:['#1a3009','#2d5016','#468b47','#a8d5a8'] },
  { id:'arctic',     name:'Arctic',    swatch:'conic-gradient(#e8f4f8,#7ec8d9,#4da6c0,#e8f4f8)',
    colors:['#ffffff','#e8f4f8','#7ec8d9','#1a6a8a'] },
  { id:'bronze',     name:'Bronze',    swatch:'conic-gradient(#3d2817,#cd7f32,#daa520,#3d2817)',
    colors:['#1a0f05','#8b4513','#cd7f32','#ffd700'] },
];

// ── Three.js setup ───────────────────────────────────────
const canvas   = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true, preserveDrawingBuffer:true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setClearColor(0x000000, 0);

const scene  = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 100);
camera.position.set(0, 0, 4.5);

const orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
orbitControls.enableDamping = true;
orbitControls.dampingFactor = 0.06;
orbitControls.enableZoom = true;

function resize(){
  const w = canvas.parentElement.clientWidth;
  const h = canvas.parentElement.clientHeight;
  renderer.setSize(w, h, false);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
}
resize();
new ResizeObserver(resize).observe(canvas.parentElement);

// ── Uniforms ─────────────────────────────────────────────
const uniforms = {
  uTime:             { value:0 },
  uDistortion:       { value:0.20 },
  uTurbulence:       { value:0.0 },
  uStyle:            { value:0.0 },
  uColorWarp:        { value:0.4 },
  uGradientType:     { value:0.0 },
  uFresnelIntensity: { value:0.5 },
  uLightBrightness:  { value:1.0 },
  uLightScale:       { value:5.0 },
  uNoiseIntensity:   { value:0.0 },
  uNoiseScale:       { value:15.0 },
  uFilamentIntensity:{ value:0.0 },
  uFilamentScale:    { value:4.0 },
  uVoronoiIntensity: { value:0.0 },
  uVoronoiScale:     { value:3.0 },
  uTopoIntensity:    { value:0.0 },
  uTopoFreq:         { value:10.0 },
  uRippleIntensity:  { value:0.0 },
  uRippleFreq:       { value:10.0 },
  uColors: { value: [
    new THREE.Color('#38bdf8'), new THREE.Color('#a78bfa'),
    new THREE.Color('#f472b6'), new THREE.Color('#c4f0ff'),
    new THREE.Color('#7ee8fa'), new THREE.Color('#ffffff'),
    new THREE.Color('#ffffff'), new THREE.Color('#ffffff'),
    new THREE.Color('#ffffff'), new THREE.Color('#ffffff'),
    new THREE.Color('#ffffff'), new THREE.Color('#ffffff'),
  ]},
  uColorCount:   { value: 5 },
  uBaseColor:    { value: new THREE.Color('#ffffff') },
  uColorOpacity: { value: 0.82 },
  // Sharp Fold
  uSharpness:    { value: 8.0 },
  uSmoothMix:    { value: 0.5 },
  uBandScale:    { value: 1.5 },
  uSharpDrift:   { value: 0.3 },
  // Fluid Glass
  uFluidSwirl:   { value: 1.0 },
  uThinFilm:     { value: 0.0 },
  uChromaticAb:  { value: 0.0 },
  uFoldLines:    { value: 0.0 },
  // Material system
  uRoughness:    { value: 0.0 },
  uMetallic:     { value: 0.0 },
  uSpecPow:      { value: 64.0 },
  uFuzzyIntensity:{ value: 0.0 },
  uEnvStrength:  { value: 0.6 },
  uAniso:        { value: 0.5 },
  uMetallicLayer:{ value: 0.0 },
};

// ── Outer color layer material (transparent, FrontSide only) ──
const material = new THREE.ShaderMaterial({
  vertexShader, fragmentShader, uniforms,
  transparent:    true,
  depthWrite:     false,
  depthTest:      true,
  polygonOffset:  true,        // push outer slightly forward → kills z-fighting dots
  polygonOffsetFactor: -1,
  polygonOffsetUnits:  -1,
  side: THREE.FrontSide,
});

// ── Inner base material (opaque, no displacement) ─────────
// Uses a minimal flat shader driven by uBaseColor uniform.
// Rendered first (renderOrder 0) to block the dark background,
// then the color layer (renderOrder 1) composites on top.
const innerVertShader = `
  uniform float uTime;
  uniform float uDistortion;
  uniform float uTurbulence;
  uniform float uStyle;
  uniform float uFilamentIntensity; uniform float uFilamentScale;
  uniform float uVoronoiIntensity;  uniform float uVoronoiScale;
  uniform float uTopoIntensity;     uniform float uTopoFreq;
  uniform float uRippleIntensity;   uniform float uRippleFreq;
  varying vec3 vNormal;

  ${noiseGLSL}

  float getDisplacement(vec3 pos){
    float freq1 = (uStyle > 0.5) ? 1.5 : 0.8;
    float d1 = snoise(pos * freq1 + uTime * 0.3) * uDistortion;
    float d2 = snoise(pos * 4.0 + uTime * 1.5) * uTurbulence * 0.5;
    float ridge = abs(snoise(pos*uFilamentScale + uTime*0.2));
    float d3 = (1.0 - pow(ridge, 0.5)) * uFilamentIntensity * 0.5;
    float d4 = (1.0 - voronoi(pos*uVoronoiScale + uTime*0.1)) * uVoronoiIntensity * 0.2;
    float topoN = snoise(pos + uTime*0.1);
    float bands = smoothstep(0.8, 1.0, sin(topoN*uTopoFreq));
    float d5 = bands * uTopoIntensity * 0.3;
    float rip = sin(length(pos.xz)*uRippleFreq + uTime*2.0)
              + sin(length(pos.xy)*uRippleFreq*0.8 - uTime*1.5);
    float d6 = rip * uRippleIntensity * 0.1;
    return d1 + d2 - d3 + d4 + d5 + d6;
  }

  void main(){
    float disp = getDisplacement(position);
    vec3 newPos = position + normal * disp;
    if(uStyle < 0.5){
      float eps = 0.1;
      float dx = getDisplacement(position+vec3(eps,0,0)) - getDisplacement(position-vec3(eps,0,0));
      float dy = getDisplacement(position+vec3(0,eps,0)) - getDisplacement(position-vec3(0,eps,0));
      float dz = getDisplacement(position+vec3(0,0,eps)) - getDisplacement(position-vec3(0,0,eps));
      vNormal = normalize(normal - vec3(dx,dy,dz)/(2.0*eps));
    } else {
      vNormal = normal;
    }
    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);
  }
`;

const innerFragShader = `
  uniform vec3 uBaseColor;
  varying vec3 vNormal;
  void main(){
    vec3 N = normalize(vNormal);
    // Simple ambient + directional shading so the base isn't flat
    vec3 L = normalize(vec3(1.5, 2.0, 1.2));
    float diff = max(0.0, dot(N, L)) * 0.35 + 0.65; // ambient 0.65
    gl_FragColor = vec4(uBaseColor * diff, 1.0);
  }
`;

const innerMaterial = new THREE.ShaderMaterial({
  vertexShader:   innerVertShader,
  fragmentShader: innerFragShader,
  uniforms,          // shares the same uniforms object — displacement stays in sync
  transparent: false,
  side: THREE.FrontSide,
});

// ── Geometry helpers ──────────────────────────────────────
// Rounded box: subdivide a sphere and squish into box shape via Lp-norm
function makeRoundedBox(size, radius, segments){
  const g = new THREE.IcosahedronGeometry(size * 0.866, segments);
  const pos = g.attributes.position;
  const v = new THREE.Vector3();
  const s = size * 0.5;
  for(let i = 0; i < pos.count; i++){
    v.fromBufferAttribute(pos, i);
    // Clamp to rounded box surface
    const cx = Math.max(-s + radius, Math.min(s - radius, v.x));
    const cy = Math.max(-s + radius, Math.min(s - radius, v.y));
    const cz = Math.max(-s + radius, Math.min(s - radius, v.z));
    const dx = v.x - cx, dy = v.y - cy, dz = v.z - cz;
    const len = Math.sqrt(dx*dx + dy*dy + dz*dz) || 1;
    pos.setXYZ(i, cx + dx/len*radius, cy + dy/len*radius, cz + dz/len*radius);
  }
  g.computeVertexNormals();
  return g;
}

// Parametric tube builder (for knots & custom curves)
function makeTube(curveFn, tubeSeg, radSeg, tubeR){
  const points = [];
  for(let i = 0; i <= tubeSeg; i++){
    const t = (i / tubeSeg) * Math.PI * 2;
    points.push(curveFn(t));
  }
  const curve = new THREE.CatmullRomCurve3(points, true);
  return new THREE.TubeGeometry(curve, tubeSeg, tubeR, radSeg, true);
}

// Star shape helper
function makeStarGeometry(spikes, outerR, innerR, height, segs){
  const shape = new THREE.Shape();
  for(let i = 0; i < spikes * 2; i++){
    const angle = (i / (spikes * 2)) * Math.PI * 2 - Math.PI / 2;
    const r = i % 2 === 0 ? outerR : innerR;
    if(i === 0) shape.moveTo(Math.cos(angle)*r, Math.sin(angle)*r);
    else shape.lineTo(Math.cos(angle)*r, Math.sin(angle)*r);
  }
  shape.closePath();
  const extrudeSettings = { depth: height, bevelEnabled: true, bevelThickness: 0.15, bevelSize: 0.15, bevelSegments: 6 };
  const g = new THREE.ExtrudeGeometry(shape, extrudeSettings);
  g.center();
  g.computeVertexNormals();
  return g;
}

// ── Geometry factory ──────────────────────────────────────
function createGeometry(type){
  let g;
  switch(type){

    case 'sphere':
      g = new THREE.IcosahedronGeometry(1.2, 64); break;

    // Rounded cube — sphere projected into box via SDF
    case 'rcube':
      g = makeRoundedBox(2.2, 0.42, 60); break;

    // Rounded tablet / pill — wide flat rounded box
    case 'rtablet': {
      g = makeRoundedBox(2.2, 0.55, 60);
      const pos = g.attributes.position;
      for(let i = 0; i < pos.count; i++){
        pos.setY(i, pos.getY(i) * 0.52);
        pos.setX(i, pos.getX(i) * 1.25);
      }
      g.computeVertexNormals(); break;
    }

    case 'torus':
      g = new THREE.TorusGeometry(1.0, 0.38, 64, 120); break;

    case 'egg': {
      g = new THREE.IcosahedronGeometry(1.2, 64);
      const pos = g.attributes.position;
      for(let i = 0; i < pos.count; i++){
        const y = pos.getY(i);
        // Squish bottom, bulge top — egg shape
        const t = y / 1.2 * 0.5 + 0.5; // 0..1
        const scale = 0.82 + 0.35 * t;
        pos.setX(i, pos.getX(i) * scale);
        pos.setZ(i, pos.getZ(i) * scale);
        pos.setY(i, y * 1.35);
      }
      g.computeVertexNormals(); break;
    }

    // Capsule: cylinder with hemisphere caps (built from sphere + scale)
    case 'capsule': {
      g = new THREE.IcosahedronGeometry(1.0, 64);
      const pos = g.attributes.position;
      for(let i = 0; i < pos.count; i++){
        const y = pos.getY(i);
        // Stretch middle, keep poles round
        const stretch = Math.abs(y) < 0.5 ? 1.6 : 1.0;
        pos.setY(i, y * 1.6 + (y > 0 ? 0.5 : y < 0 ? -0.5 : 0));
      }
      g.computeVertexNormals(); break;
    }

    // Cone — smooth SphereGeometry capped
    case 'cone':
      g = new THREE.ConeGeometry(1.2, 2.4, 80, 40, false);
      g.computeVertexNormals(); break;

    // Hemisphere / dome
    case 'hemisphere': {
      g = new THREE.IcosahedronGeometry(1.3, 64);
      const pos = g.attributes.position;
      for(let i = 0; i < pos.count; i++){
        if(pos.getY(i) < 0) pos.setY(i, 0); // clip bottom hemisphere
      }
      g.computeVertexNormals(); break;
    }

    // Trefoil knot
    case 'trefoil':
      g = new THREE.TorusKnotGeometry(1.0, 0.34, 160, 32, 2, 3); break;

    // Twisted torus — torus knot with twist
    case 'twist':
      g = new THREE.TorusKnotGeometry(0.9, 0.30, 160, 28, 3, 4); break;

    // 3D Star
    case 'star': {
      g = makeStarGeometry(5, 1.1, 0.48, 0.5, 8);
      // Smooth it a bit by scaling
      break;
    }

    // Link / chain knot
    case 'chain':
      g = new THREE.TorusKnotGeometry(1.0, 0.24, 160, 28, 3, 2); break;

    // Crystal kept in JS for organic mode (not in UI but usable)
    case 'crystal': {
      g = new THREE.IcosahedronGeometry(1.3, 64);
      const pos = g.attributes.position;
      const v = new THREE.Vector3();
      for(let i=0;i<pos.count;i++){
        v.fromBufferAttribute(pos,i).normalize();
        const len = Math.abs(v.x)+Math.abs(v.y)+Math.abs(v.z);
        v.multiplyScalar(1.3/len);
        pos.setXYZ(i,v.x,v.y,v.z);
      }
      g.computeVertexNormals(); break;
    }

    default:
      g = new THREE.IcosahedronGeometry(1.2, 64);
  }
  return g;
}

let innerMesh = null;
let outerMesh = null;

function setShape(type){
  // Remove old meshes
  if(innerMesh){ scene.remove(innerMesh); innerMesh.geometry.dispose(); }
  if(outerMesh){ scene.remove(outerMesh); outerMesh.geometry.dispose(); }

  const geom = createGeometry(type);
  const geomClone = geom.clone(); // inner and outer share same shape but separate geometry instances

  // Inner: opaque base color, renders first
  innerMesh = new THREE.Mesh(geom, innerMaterial);
  innerMesh.renderOrder = 0;

  // Outer: transparent color layer, renders on top
  outerMesh = new THREE.Mesh(geomClone, material);
  outerMesh.renderOrder = 1;

  scene.add(innerMesh);
  scene.add(outerMesh);
}
setShape('sphere');

// Keep both meshes rotation in sync — we'll drive innerMesh, copy to outer
function syncMeshRotation(dt){
  if(!innerMesh || !outerMesh) return;
  if(autoRotate && isPlaying){
    innerMesh.rotation.y += dt * 0.18 * speedMult;
    innerMesh.rotation.x += dt * 0.06 * speedMult;
  }
  outerMesh.rotation.copy(innerMesh.rotation);
}

// ── State ────────────────────────────────────────────────
let isPlaying = true;
let speedMult = 0.6;
let autoRotate = true;
const clock = new THREE.Clock();

// ── Render loop ──────────────────────────────────────────
let frameCount=0, fpsTimer=0;
function animate(){
  requestAnimationFrame(animate);
  const dt = clock.getDelta();
  frameCount++; fpsTimer+=dt;
  if(fpsTimer>=1){ document.getElementById('fps-val').textContent=frameCount; frameCount=0; fpsTimer=0; }

  if(isPlaying){
    uniforms.uTime.value += dt * speedMult;
    document.getElementById('time-val').textContent = uniforms.uTime.value.toFixed(1)+'s';
  }

  syncMeshRotation(dt);

  orbitControls.update();
  renderer.render(scene, camera);
}
animate();

// ── UI wiring ────────────────────────────────────────────

// Shape buttons
document.querySelectorAll('.shape-btn').forEach(btn=>{
  btn.addEventListener('click',()=>{
    document.querySelectorAll('.shape-btn').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    setShape(btn.dataset.shape);
  });
});

// Style buttons
document.querySelectorAll('.style-btn').forEach(btn=>{
  btn.addEventListener('click',()=>{
    document.querySelectorAll('.style-btn').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    uniforms.uStyle.value = btn.dataset.style==='smooth' ? 0.0 : 1.0;
  });
});

// ── Dynamic color palette system ─────────────────────────
const MAX_COLORS = 12;
const MIN_COLORS = 2;
let paletteColors = ['#38bdf8','#a78bfa','#f472b6','#c4f0ff','#7ee8fa']; // default: Pearl theme

function syncColorsToShader(){
  const n = paletteColors.length;
  uniforms.uColorCount.value = n;
  for(let i = 0; i < 12; i++){
    uniforms.uColors.value[i].setStyle(paletteColors[i] || paletteColors[n-1]);
  }
}

function renderColorGrid(){
  const grid = document.getElementById('color-grid');
  grid.innerHTML = '';

  paletteColors.forEach((hex, idx) => {
    const item = document.createElement('div');
    item.className = 'color-item';

    const label = document.createElement('label');
    label.textContent = `C${idx+1}`;

    const input = document.createElement('input');
    input.type = 'color';
    input.value = hex;
    input.addEventListener('input', e => {
      paletteColors[idx] = e.target.value;
      syncColorsToShader();
      document.querySelectorAll('.theme-btn').forEach(b=>b.classList.remove('active'));
    });

    // Remove button (only if more than MIN_COLORS)
    const removeBtn = document.createElement('button');
    removeBtn.className = 'color-remove';
    removeBtn.textContent = '×';
    removeBtn.title = 'Remove color';
    removeBtn.addEventListener('click', e => {
      e.stopPropagation();
      if(paletteColors.length <= MIN_COLORS) return;
      paletteColors.splice(idx, 1);
      syncColorsToShader();
      renderColorGrid();
      document.querySelectorAll('.theme-btn').forEach(b=>b.classList.remove('active'));
    });

    item.appendChild(label);
    item.appendChild(input);
    if(paletteColors.length > MIN_COLORS) item.appendChild(removeBtn);
    grid.appendChild(item);
  });

  // Add color button (if under max)
  if(paletteColors.length < MAX_COLORS){
    const addItem = document.createElement('div');
    addItem.className = 'color-item';
    const addLabel = document.createElement('label');
    addLabel.textContent = `+`;
    const addBtn = document.createElement('button');
    addBtn.className = 'add-color-btn';
    addBtn.textContent = '+';
    addBtn.title = 'Add color';
    addBtn.addEventListener('click', () => {
      // default: interpolate between last two colors
      const last = paletteColors[paletteColors.length - 1];
      paletteColors.push(last);
      syncColorsToShader();
      renderColorGrid();
    });
    addItem.appendChild(addLabel);
    addItem.appendChild(addBtn);
    grid.appendChild(addItem);
  }
}

// ── Theme buttons — build dynamically ─────────────────────
function buildThemeGrid(){
  const grid = document.getElementById('theme-grid');
  grid.innerHTML = '';
  THEMES.forEach((t, i) => {
    const btn = document.createElement('button');
    btn.className = 'theme-btn' + (i === 0 ? ' active' : '');
    btn.dataset.themeId = t.id;
    btn.innerHTML = `
      <div class="theme-swatch" style="background:${t.swatch}"></div>
      <span>${t.name}</span>`;
    btn.addEventListener('click', () => {
      document.querySelectorAll('.theme-btn').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      paletteColors = [...t.colors];
      syncColorsToShader();
      renderColorGrid();
      // Auto-switch to Fluid Glass when Pearl theme is selected
      if(t.id === 'iridescent'){
        const sel = document.getElementById('gradientType');
        sel.value = 'fluid';
        sel.dispatchEvent(new Event('change'));
      }
    });
    grid.appendChild(btn);
  });
}

buildThemeGrid();
renderColorGrid();
syncColorsToShader();

// ── Material preset system ────────────────────────────────
// Each preset defines [roughness, metallic, specPow, fuzzy, envStrength, aniso, metallicLayer]
const MAT_PRESETS = {
  glossy:   [0.00, 0.00, 128, 0.00, 0.6, 0.5, 0],
  matte:    [0.85, 0.00,   4, 0.00, 0.0, 0.0, 0],
  metallic: [0.05, 0.90,  96, 0.00, 0.8, 0.7, 1],
  plastic:  [0.15, 0.00,  80, 0.00, 0.0, 0.0, 0],
  fuzzy:    [0.70, 0.00,   3, 0.85, 0.0, 0.0, 0],
  ceramic:  [0.30, 0.00,  48, 0.00, 0.0, 0.0, 0],
};

function applyMatPreset(name){
  const [rough, metal, spec, fuzz, env, aniso, metalLayer] = MAT_PRESETS[name];
  // Set uniforms
  uniforms.uRoughness.value     = rough;
  uniforms.uMetallic.value      = metal;
  uniforms.uSpecPow.value       = spec;
  uniforms.uFuzzyIntensity.value= fuzz;
  uniforms.uEnvStrength.value   = env;
  uniforms.uAniso.value         = aniso;
  uniforms.uMetallicLayer.value = metalLayer;
  // Sync sliders
  setSliderVal('roughness',    rough);
  setSliderVal('metallic',     metal);
  setSliderVal('specPow',      spec);
  setSliderVal('fuzzyIntensity', fuzz);
  setSliderVal('envStrength',  env);
  setSliderVal('aniso',        aniso);
  // Sync metallic toggle
  const toggle = document.getElementById('metallic-toggle');
  toggle.checked = metalLayer > 0.5;
  document.getElementById('metallic-controls').style.display = toggle.checked ? 'block' : 'none';
}

function setSliderVal(id, val){
  const el = document.getElementById(id);
  if(!el) return;
  el.value = val;
  const dispId = el.id + '-val';
  // specPow display shows integer, others 1 decimal
  const disp = document.getElementById(dispId);
  if(disp) disp.textContent = (id === 'specPow') ? Math.round(val) : parseFloat(val).toFixed(1);
}

document.querySelectorAll('.mat-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.mat-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    applyMatPreset(btn.dataset.mat);
  });
});

// Metallic toggle
document.getElementById('metallic-toggle').addEventListener('change', e => {
  uniforms.uMetallicLayer.value = e.target.checked ? 1.0 : 0.0;
  document.getElementById('metallic-controls').style.display = e.target.checked ? 'block' : 'none';
});

// Gradient type (0=linear, 1=radial, 2=fluid glass, 3=sharp fold)
document.getElementById('gradientType').addEventListener('change',e=>{
  const v = e.target.value;
  uniforms.uGradientType.value = {linear:0.0, radial:1.0, fluid:2.0, sharp:3.0}[v] ?? 0.0;
  document.getElementById('fluid-controls').style.display  = v==='fluid'  ? 'block' : 'none';
  document.getElementById('sharp-controls').style.display  = v==='sharp'  ? 'block' : 'none';
  if(v === 'fluid'){
    uniforms.uThinFilm.value    = parseFloat(document.getElementById('thinFilm').value);
    uniforms.uChromaticAb.value = parseFloat(document.getElementById('chromaticAb').value);
    uniforms.uFoldLines.value   = parseFloat(document.getElementById('foldLines').value);
    uniforms.uFluidSwirl.value  = parseFloat(document.getElementById('fluidSwirl').value);
  }
  if(v === 'sharp'){
    uniforms.uSharpness.value  = parseFloat(document.getElementById('sharpness').value);
    uniforms.uSmoothMix.value  = parseFloat(document.getElementById('smoothMix').value);
    uniforms.uBandScale.value  = parseFloat(document.getElementById('bandScale').value);
    uniforms.uSharpDrift.value = parseFloat(document.getElementById('sharpDrift').value);
  }
});

// Generic slider binder
function bindSlider(id, displayId, setter){
  const el=document.getElementById(id), disp=document.getElementById(displayId);
  el.addEventListener('input',()=>{
    const v=parseFloat(el.value);
    disp.textContent=v.toFixed(1);
    setter(v);
  });
}

bindSlider('colorOpacity',    'colorOpacity-val',    v => uniforms.uColorOpacity.value = v);
document.getElementById('baseColor').addEventListener('input', e => {
  uniforms.uBaseColor.value.setStyle(e.target.value);
});
// Material sliders
bindSlider('roughness',      'roughness-val',   v=>{ uniforms.uRoughness.value=v; });
bindSlider('metallic',       'metallic-val',    v=>{ uniforms.uMetallic.value=v; });
bindSlider('specPow',        'specPow-val',     v=>{ uniforms.uSpecPow.value=v;
  document.getElementById('specPow-val').textContent=Math.round(v); });
bindSlider('fuzzyIntensity', 'fuzzy-val',       v=>{ uniforms.uFuzzyIntensity.value=v; });
bindSlider('envStrength',    'envStrength-val', v=>{ uniforms.uEnvStrength.value=v; });
bindSlider('aniso',          'aniso-val',       v=>{ uniforms.uAniso.value=v; });

// Sharp Fold sliders
bindSlider('sharpness',  'sharpness-val',  v=>uniforms.uSharpness.value=v);
bindSlider('smoothMix',  'smoothMix-val',  v=>uniforms.uSmoothMix.value=v);
bindSlider('bandScale',  'bandScale-val',  v=>uniforms.uBandScale.value=v);
bindSlider('sharpDrift', 'sharpDrift-val', v=>uniforms.uSharpDrift.value=v);

// Fluid Glass sliders
bindSlider('fluidSwirl',  'fluidSwirl-val',  v=>uniforms.uFluidSwirl.value=v);
bindSlider('thinFilm',    'thinFilm-val',    v=>uniforms.uThinFilm.value=v);
bindSlider('chromaticAb', 'chromaticAb-val', v=>uniforms.uChromaticAb.value=v);
bindSlider('foldLines',   'foldLines-val',   v=>uniforms.uFoldLines.value=v);

bindSlider('colorWarp',       'colorWarp-val',       v=>uniforms.uColorWarp.value=v);
bindSlider('fresnelIntensity','fresnel-val',          v=>uniforms.uFresnelIntensity.value=v);
bindSlider('lightBrightness', 'lightBrightness-val',  v=>uniforms.uLightBrightness.value=v);
bindSlider('lightScale',      'lightScale-val',       v=>uniforms.uLightScale.value=v);
bindSlider('speed',           'speed-val',            v=>speedMult=v);
bindSlider('distortion',      'distortion-val',       v=>uniforms.uDistortion.value=v);
bindSlider('turbulence',      'turbulence-val',       v=>uniforms.uTurbulence.value=v);
// ── Effect groups: accordion + intensity badge + slider binding ──
function bindFxGroup(groupId, badgeId, intensityId, intensityDisplayId, intensityUniform, extraBindings){
  const group   = document.getElementById(groupId);
  const header  = group.querySelector('.fx-header');
  const badge   = document.getElementById(badgeId);
  const slider  = document.getElementById(intensityId);

  // Accordion toggle
  header.addEventListener('click', () => group.classList.toggle('open'));

  // Intensity slider → uniform + badge + active state
  slider.addEventListener('input', () => {
    const v = parseFloat(slider.value);
    document.getElementById(intensityDisplayId).textContent = v.toFixed(1);
    badge.textContent = v.toFixed(1);
    intensityUniform(v);
    const isActive = v > 0.001;
    group.classList.toggle('active', isActive);
    // Auto-open when turned on from 0
    if(isActive && !group.classList.contains('open')) group.classList.add('open');
  });

  // Extra sliders inside the group
  if(extraBindings) extraBindings();
}

bindFxGroup('fx-filament', 'fx-filament-badge', 'filamentIntensity', 'filament-val',
  v => uniforms.uFilamentIntensity.value = v,
  () => bindSlider('filamentScale', 'filamentScale-val', v => uniforms.uFilamentScale.value = v)
);

bindFxGroup('fx-topo', 'fx-topo-badge', 'topoIntensity', 'topo-val',
  v => uniforms.uTopoIntensity.value = v,
  () => bindSlider('topoFreq', 'topoFreq-val', v => uniforms.uTopoFreq.value = v)
);

bindFxGroup('fx-ripple', 'fx-ripple-badge', 'rippleIntensity', 'ripple-val',
  v => uniforms.uRippleIntensity.value = v,
  () => bindSlider('rippleFreq', 'rippleFreq-val', v => uniforms.uRippleFreq.value = v)
);

bindFxGroup('fx-noise', 'fx-noise-badge', 'noiseIntensity', 'noise-val',
  v => uniforms.uNoiseIntensity.value = v,
  () => bindSlider('noiseScale', 'noiseScale-val', v => uniforms.uNoiseScale.value = v)
);

// Auto-rotate
document.getElementById('rotate-toggle').addEventListener('change',e=>{
  autoRotate=e.target.checked;
  if(!autoRotate){ orbitControls.autoRotate=false; }
});

// Play / pause
const playIcon=document.getElementById('play-icon'), pauseIcon=document.getElementById('pause-icon');
document.getElementById('play-btn').addEventListener('click',()=>{
  isPlaying=!isPlaying;
  playIcon.style.display  = isPlaying?'none':'';
  pauseIcon.style.display = isPlaying?'':'none';
});

// ── Toast ────────────────────────────────────────────────
function toast(msg){
  const el=document.getElementById('toast');
  el.textContent=msg; el.classList.add('show');
  setTimeout(()=>el.classList.remove('show'),2200);
}

// ── Export ───────────────────────────────────────────────
function exportImage(type){
  renderer.render(scene,camera);
  canvas.toBlob(blob=>{
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a');
    a.href=url; a.download=`liquid-shape.${type==='image/jpeg'?'jpg':'png'}`;
    a.click(); URL.revokeObjectURL(url);
    toast(`Saved as ${a.download}`);
  }, type, 0.96);
}
document.getElementById('export-png').addEventListener('click',()=>exportImage('image/png'));
document.getElementById('export-jpg').addEventListener('click',()=>exportImage('image/jpeg'));

// WebM video
let mediaRecorder=null, chunks=[];
const recBtn=document.getElementById('export-video');
const recDot=document.getElementById('rec-dot');

recBtn.addEventListener('click',()=>{
  if(mediaRecorder && mediaRecorder.state==='recording'){
    mediaRecorder.stop();
    recBtn.textContent='● Record WebM';
    recBtn.classList.remove('danger'); recBtn.classList.add('primary');
    recDot.style.display='none';
    return;
  }
  chunks=[];
  const mime = MediaRecorder.isTypeSupported('video/webm;codecs=vp9')
    ? 'video/webm;codecs=vp9' : 'video/webm';
  mediaRecorder=new MediaRecorder(canvas.captureStream(60),{mimeType:mime,videoBitsPerSecond:8_000_000});
  mediaRecorder.ondataavailable=e=>{if(e.data.size>0)chunks.push(e.data);};
  mediaRecorder.onstop=()=>{
    const blob=new Blob(chunks,{type:mime});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download='liquid-shape.webm'; a.click();
    URL.revokeObjectURL(url); toast('Video saved → liquid-shape.webm'); mediaRecorder=null;
  };
  mediaRecorder.start();
  recBtn.textContent='■ Stop Recording';
  recBtn.classList.remove('primary'); recBtn.classList.add('danger');
  recDot.style.display='block';
  setTimeout(()=>{ if(mediaRecorder&&mediaRecorder.state==='recording') recBtn.click(); },8000);
});
</script>
</body>
</html>
